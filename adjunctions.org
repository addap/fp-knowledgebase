* Description
Just to expand on the connection between State and Store, all monads arise from a composition of adjoint functors. It's commonly known that the functors (r -> _ ) (a.k.a. Reader) and (_ , r) (flipped works too, but doesn't fit the usual presentation of State in Haskell, and can't be a Functor instance in Haskell) are adjoint, and if you compose them one way (s -> (_ , s)) you'll get a monad, and if you compose them the other way ((s -> _, s)) you'll get a comonad.

What does that mean and are there more examples
* Resources
** TODO [[https://www.reddit.com/r/haskell/comments/eoajf1/adjunctions_in_the_wild_foldl/][Reddit on foldl]]
** Runar Bjarnason on Adjunctions
*** DONE [[https://www.youtube.com/watch?v=f-kdpR0BPqo][#1]]
*** DONE [[https://www.youtube.com/watch?v=BLk4DlNZkL8][#2]]
*** DONE [[https://www.youtube.com/watch?v=TNtntlVo4LY][#3]]
** TODO [[http://www.cs.ox.ac.uk/ralf.hinze/LN.pdf][Ralf Hinze: Generic Programming With Adjunctions]]
** TODO [[https://haslab.uminho.pt/pfsilva/publications/galculator-functional-prototype-galois-connection-based-proof-assistant][Galculator Proof Assistant Paper using Adjunctions]]
** TODO [[http://www.cs.ox.ac.uk/ralf.hinze/publications/WGP10.pdf][Ralf Hinze: Reason isomorphically]]
From Bartosz Milewski's Book. We can use adjunctions to prove some lemmas about algebraic datatypes. They mostly prove the same stuf that bartosz also does, i.e. the "high-school" notions about exponentials.
But they also state "Whenwe came to model recursive datatypes as least fixpoints of func-tors, the property that left adjoints preserve initial objects was in-valuable."
*** TODO how exactly do they mean that?
** TODO [[https://stackoverflow.com/a/56704938/12035298][Usecases for adjunctions in Haskell]]
Try out the choice -| dilemma adjunction (which should be a specialized version of sum -| diag)
** TODO [[https://ris.utwente.nl/ws/portalfiles/portal/6769987/db-utwente-406143E9.pdf][Fokkinga, Meertens: Adjunctions]]
In this paper they explore the _calculational_ aspects of adjunctions (I presume they exploit the homset isomorphism)
** TODO [[https://old.reddit.com/r/haskell/comments/4zvyiv/what_are_some_example_adjunctions_from_monads_or/][What Are Some Example Adjunctions from Monads (or vice versa)? : haskell]]
** DONE [[file:playground/src/adjunctions.lhs::Today we'll be looking into Kmett's][Chris Penner: Adjunction Battleship]]
All in all not a very interesting article because adjunctions don't seem to be very useful in Haskell. But it has the zapWithAdjunction function which does seem useful. It's implementation is certainly driven by types and easy enough but a meaning still eludes me.
*** TODO intuition behind the zapWithAdjunction function?
** DONE [[https://mail.haskell.org/pipermail/haskell-cafe/2008-March/040203.html][Functional Programmer's Intuition for Adjunctions]]
The following is a very nice intuition for the homset definition of adjunctions and why the free/forgetful monoid functor are adjunct.
Any homomorphism, f, between monoids is completely determined once you
know where a set of generators of the monoid map under the
homomorphism, and vice versa. All of the other elements can be deduced
using f(1) = 1 and f(xy)=f(x)f(y). So if F(a) is the free monoid
generated by a, then a homomorphism F(a)->b is completely determined
by a function a->U(b), and vice versa.
** TODO [[http://www.logicmatters.net/resources/pdfs/Galois.pdf][Semantic Structure adjunction/galois connection]]
Seems to be very advanced.
From Wikipedia: A very general comment of William Lawvere[6] is that syntax and semantics are adjoint: take A to be the set of all logical theories (axiomatizations), and B the power set of the set of all mathematical structures. For a theory T ∈ A, let F(T) be the set of all structures that satisfy the axioms T; for a set of mathematical structures S ∈ B, let G(S) be the minimum of the axiomatizations which approximate S. We can then say that F(T) is a subset of S if and only if T logically implies G(S): the "semantics functor" F and the "syntax functor" G form a monotone Galois connection, with semantics being the lower adjoint

* Examples
** (,s) -| (s ->)
At the beginning of talk #3
** minKeys ( locks ) <<= keys <=> locks <<= maxLocks ( keys )
From Runar's talk #2
In this example it is easy to see how minKeys is the easiest solution to the locks, while maxLocks is the hardest problems that some locks can solve. I.e. the intuition that Runar often hints at in his adjunction talks.
Both maxLocks and minKeys are the functors in this example.
** sum -| delta -| product
Runar talked about this @36:00 in talk #3
** option -| forgetOption
what does the comonad of that look like? In his talk Runar says that we also have an option comonad (and similarly a list comonad for the monoid example) but it's a comonad in the category of pointed types (monoids). He said one direction of the adjunctor combining is often not that interesting and I guess     that happens here.
*** TODO So these functors don't seem to be endofunctors. In the store/state case they were. Is it always the case that endofunctor form interesting monad/comonad pairs?
** Free -| Forget for any algebraic datatype
So since any algebraic datatype is a free functor, there is always a forgetful functor that is right adjoint so any datatype gives rise to a monad? They are probably mostly uninteresting I imagine. And it should be only algebraic datatypes with a type argument.
** compress & decompress of data like images is maybe an adjunction
* all adjunctions (in Haskell) are isomorphic to (,s) -| (s ->)
https://twitter.com/shachaf/status/887892575192883201 proof given here.
Seems to work in any category that has a terminal object.
*** TODO write up the steps of the proof. I think one of them is Yoneda's Lemma
* Questions
** DONE I wondered whether U o F is always isomorphic to the identity functor because "U just forgets the extra structure of F". So is that always the case?
No, the fastest way to answer is that U o F is a monad T and not every monad is isomorphic to the identity.
For example in the free monoid we add all possible multiplications of the generators (only identifying multiplication with unit and associative multiplications respectively) and the forgetful functor maps the monoid to its underlying set.
So U (F X) for some set X is the set of strings of elements of X (i.e. the list monad), it's not isomorphic to X.
If we also had the (U o F) -> Id morphism then U o f would be both a monad and a comonad. I think there was an example beside the identity functor where that happened. [[https://stackoverflow.com/questions/16551734/can-a-monad-be-a-comonad][Yes there was]] e.g. nonempty lists are both a monad and comonad and arise from the cofree comonad.
** DONE so that was the wrong question to ask. It shoudl rather be, is F o U always the identity functor. because you take some algebraic structure, forget its laws and then build the free structure again.
   CLOSED: [2020-10-10 Sa 17:02]
   this can also be answered negatively. For example some monoid that is not the free monoid. If you forget it's a monoid and treat it as a set, then build the free monoid again you don't end up in the same spot (e.g. the natural numbers mod n as a set. then the free monoid on that will be lists of natural numbers up to n-1)
